# Implementation of Local Best Response calculation for a lower bound on
# exploitability from https://arxiv.org/abs/1612.07547

# I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
# way faster and still gives decent results. I'm also having the exploiter
# check/call on the preflop and flop.

from itertools import combinations
import numpy as np
from tqdm import trange
from texas_utils import get_deck
from trainer_utils import normalize
from texas_hands import TexasHand

ITERS = 100000
BIG_BLIND = 200
STACK_SIZE = 20000

def check_call(street, stacks):
    if street == "preflop" and sum(stacks.values()) == 2*STACK_SIZE:
        return {"action": "bet", "amount": BIG_BLIND}
    elif stacks["opponent"] == stacks["exploiter"]:
        return {"action": "check", "amount": 0}
    else:
        return {"action": "call", "amount": abs(stacks["opponent"] - stacks["exploiter"])}


def cpu_action(street, stacks):
    return check_call(street, stacks)

def local_best_response(street, stacks):
    if True: #street == "preflop" or street == "flop":
        return check_call(street, stacks)
    else:
        # local best response
        pass


def update_range(opp_range, strategy):
    return opp_range    # Since the opponent is always calling here, we get no new range information


def whose_turn(street, dealer):
    if street == "preflop":
        return dealer
    elif dealer == "exploiter":
        return "opponent"
    else:
        return "exploiter"


# TODO: Consider when the opponent is the dealer
def play_hand(strategy):
    deck = get_deck()
    np.random.shuffle(deck)
    exploiter_hole = deck[:2]
    opponent_hole = deck[2:4]
    board = deck[4:9]

    dealer = "exploiter"
    if np.random.random() > 0.5:
        dealer = "opponent"

    opp_range = {frozenset((card1, card2)): 1 for (card1, card2) in combinations(deck, 2)}
    normalize(opp_range)

    stacks = {"exploiter": STACK_SIZE, "opponent": STACK_SIZE}
    streets = 'preflop', 'flop', 'turn', 'river'
    history = {street: [] for street in streets}

    for street in 'preflop', 'flop', 'turn', 'river':
        turn = whose_turn(street, dealer)
        while True:
            if turn == "exploiter":
                action = local_best_response(street, stacks)
                stacks["exploiter"] -= action["amount"]
                turn = "opponent"
                if action["action"] == "fold":
                    return stacks["exploiter"] - STACK_SIZE
            else:
                action = cpu_action(street, stacks)
                opp_range = update_range(opp_range, strategy)
                stacks["opponent"] -= action["amount"]
                turn = "exploiter"
                if action["action"] == "fold":
                    return STACK_SIZE - stacks["opponent"]
            history[street].append(action)
            if len(history[street]) >= 2 and stacks["exploiter"] == stacks["opponent"]:
                break

    # Showdown
    exploiter_hand = TexasHand(exploiter_hole + board)
    opponent_hand = TexasHand(opponent_hole + board)
    half_pot = STACK_SIZE - stacks["exploiter"]
    if exploiter_hand > opponent_hand:
        return half_pot
    elif opponent_hand > exploiter_hand:
        return -half_pot
    else:
        return 0    # split pot


def exploit(strategy):
    exploitability = 0
    for i in trange(ITERS):
        exploitability += play_hand(strategy)
    return exploitability / ITERS


if __name__ == '__main__':
    strategy = {}
    print(exploit(strategy))