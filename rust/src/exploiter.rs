// Implementation of Local Best Response calculation for a lower bound on
// exploitability from https://arxiv.org/abs/1612.07547

// I'm using the "fcpa" (fold, call, pot, all-in) action choices from the paper, which is
// way faster and still gives decent results. I'm also having the exploiter
// check/call on the preflop and flop.

// Right now: Sanity check with chump strategies, like always call.

use crate::card_utils;
use crate::card_utils::Card;
use crate::trainer_utils::*;
use std::collections::HashMap;
use rand::seq::SliceRandom;

const ITERS: i32 = 100;

pub fn exploitability(strategy: &HashMap<InfoSet, Node>) -> f64 {
    println!("[INFO] Calculating exploitability...");
    let mut exploits = Vec::new();
    for i in 0..ITERS {
        let e = play_hand(strategy) / (BIG_BLIND as f64);
        exploits.push(e);
    }
    let mean = statistical::mean(&exploits);
    let std = statistical::standard_deviation(&exploits, Some(mean));
    let confidence = 1.96 * std / (ITERS as f64).sqrt();
    println!("Exploitability: {} +/- {} BB/h", mean, confidence);
    mean
}

fn play_hand(strategy: &HashMap<InfoSet, Node>) -> f64 {
    let mut deck = card_utils::deck();
    let mut rng = &mut rand::thread_rng();
    deck.shuffle(&mut rng);
    let mut opp_range = construct_opponent_range(&deck);
    let mut stacks = [STACK_SIZE, STACK_SIZE];
    let dealer = [0, 1].choose(&mut rng).unwrap().clone();

    for street in &[PREFLOP, FLOP, TURN, RIVER] {
        let whose_turn = match street.clone() {
            PREFLOP => dealer,
            _ => 1 - dealer,
        };
        remove_blockers(&mut opp_range, board, street.clone());
        START HERE: Keep translating this from exploitability.py. It's a lot of code (300 lines)
        but it'll be worth it to have fast exploitability measurement. This is
        grunt work but it'll be worth it to verify that my CFR strategy is good.
    }
    unimplemented!();
}

fn construct_opponent_range(deck: &[Card]) -> HashMap<Vec<Card>, f64> {
    unimplemented!();
}

fn remove_blockers(opp_range: &mut HashMap<Vec<Card>, f64>, board: &[Card], street: usize) {
    unimplemented!();
    // TODO: Should I normalize the range at the end of this?
}
// trainer -> exploiter -> trainer_utils
//         -> trainer_utils
